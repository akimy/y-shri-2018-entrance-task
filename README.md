# Яндекс переговорки
## Тестовое задание для вступления в школу разработки интерфейсов Yandex 2018

> Приветствую ревьювера этого задания. Если вы читаете это, значит я все же завершил создание этого приложения и посчитал его достаточно завершенным, чтобы отправить на проверку вам. Не зависимо от вашего вердикта, я бы хотел поблагодарить именно Вас, за потраченное время на проверку данного кода и в случае неудачи хотел бы получить обратную связь на ar.vaganov@gmail.com, с информацией о том, что мне необходимо улучшить в codestyle и/или подходе в процессе разработки. На этом вступительная часть завершается.

### Инициализация
#### Запуск приложения в продакшен
```
npm install
npm run build - сборка продакшен версии интерфейса
npm run start - запуск NodeJS (GraphQL API + HTML разметка)   
```

#### Запуск в режиме разработки
```
npm install
npm run dev - запуск webpack сборщика в watch режиме.

// Во второй консоли
npm run start - запуск NodeJS (GraphQL API + HTML разметка)   
```
Запуск тестов
```
In development
```
Запуск линтера, проверка codestyle
```
npm run lint
```
Сброс базы данных
```
npm run reset-db
```


### Задание 1. Комплексное, починка GraphQL API
1. При первом запуске компилятор в консоли говорит нам о неправильно введенных данных для Sequelize ORM. Изучив документацию Sequelize добавляем в конструктор Sequelize, при создании инстанса, аргументы для пароля и хоста. Сервер Node.js теперь запускается, слушает запрос на localhost:3000, работает индекс роут, но graphql роут не работает.
2. Рефракторинг кода. Поскольку в этом задании нам предоставлена некоторая свобода действий, мы будем использовать современный ES6 синтакс (импорты, деструктуризацию, spread оператор и пр.). Поправим уже существующие импорты, чтобы все выглядело в едином codestyle. В файле /graphql/routes ошибка при использовании graphqlHTTP, исправляем ее согласно спецификации на сайте GraphQL. Подключаем babel в зависимости, и немного правим run dev скрипт для запуска nodaemon, чтобы он получал скомпилированные данные из ноды babel. Перезапускаем приложение, GUI GraphiQL теперь доступен на localhost:3000/graphql.
3. Самое время подключить Eslint и исправить ошибки в коде, которые он поможет нам найти, я использую air-bnb пресет для codestyle, ставим расширение и для реакта (пригодится уже во втором задании). Видим, что есть ошибка в корневом index.js, отсутствует зависимость body-parser, middleware для обработки POST-запросов, устанавливаем ее.
4. Проверяем запросы в GraphiQL согласно схеме. "query events" не возвращает значения, т.к. название переменной arguments в resolvers/query,js было изменено, исправляем это. Рисуем на листке бумаги схему БД, смотрим какие еще отношения нам могут понадобиться. Исправляем ошибку отсутствия return (в resolvers/index.js), добавляем отсутствующую ассоциацию User->Events, отсутствующий релейшен в models/scheme.js Room.hasMany(Event) (теперь мы можем запрашивать все события в определенной комнате). В graphQL файле, где описываются типы, добавляем в UserInput тип - необязательное поле avatarUrl (чтобы можно было создавать пользователя с изображениями и для Room - поле events: [Event], чтобы получать все события комнаты), добавляем в резолверы геттер для событий комнаты, чтобы это все заработало. В интерефейсе localhost:3000/graphiQL проверяем все мутации. Отсутствует резолвер для мутации addUserToEvent, напишем его. В резолвере changeEventRoom была допущенна ошибка, исправляем ее. Все мутации теперь работают.

### Задание 2. Верстка
#### Настройка окружения для разработки и продакшен-билда нашего приложения.
Поскольку мы будем использовать в нашем проекте React, (мне он нравится), нам понадобится соответствующее окружение для разработки и финальной сборки нашего приложения в продакшен. Для начала добавим в наши зависимости cross-env, это позволит нам указывать переменную окружения и в зависимости от нее осуществлять ветвление в вебпаке (при компиляции в продакшен есть необходимость в минифиакации, не нужен watch режим и пр.). Далее, добавим в зависимости, собственно, Реакт (react и react-dom). Установим webpack v3+ и лоадеры к нему: babel-loader, babel-preset-react для того, чтобы webpack мог компилировать ES6 синтакс и JSX в Javascript более старой редакции, css-loader, sass-loader, лоадеры вебпака для сборки нашего scss. node-sass для компиляции scss в css и, в заключение, extract-text-webpack-plugin для вывода скомпилированного css в один файл на продакшен билде. file-loader для переноса статичных файлов (изображений и шрифтов). Изменим немного файловую структуру нашего проекта, добавим папку client (где будет хранится исходный код наших клиентских компонентов) и папку public где будет хранится bundle.js и style.css скомпилированные версии наших исходных кодов для javascript и cascade stylesheets соответственно, а так же статика. Редактируем конфиг вебпака. Готово.
