# Яндекс переговорки
## Тестовое задание для вступления в школу разработки интерфейсов Yandex 2018

> Приветствую ревьювера этого задания. Если вы читаете это, значит я все же завершил создание этого приложения и посчитал его достаточно завершенным, чтобы отправить на проверку вам. Не зависимо от вашего вердикта, я бы хотел поблагодарить именно Вас, за потраченное время на проверку данного кода и в случае неудачи хотел бы получить обратную связь на ar.vaganov@gmail.com, с информацией о том, что мне необходимо улучшить в codestyle и/или подходе в процессе разработки. На этом вступительная часть завершается.

### Инициализация
Запуск приложения
```
npm install
npm run dev   
```

Запуск тестов
```
in process
```
### Задание 1. Комплексное, починка GraphQL API
1. При первом запуске компилятор в консоли говорит нам о неправильно введенных данных для Sequelize ORM. Изучив документацию Sequelize добавляем в конструктор Sequelize, при создании инстанса, аргументы для пароля и хоста. Сервер Node.js теперь запускается, слушает запрос на localhost:3000, работает индекс роут, но graphql роут не работает.
2. Рефракторинг кода. Поскольку в этом задании нам предоставлена некоторая свобода действий, мы будем использовать современный ES6 синтакс (импорты, деструктуризацию, spread оператор и пр.). Поправим уже существующие импорты, чтобы все выглядело в едином codestyle. В файле /graphql/routes ошибка при использовании graphqlHTTP, исправляем ее согласно спецификации на сайте GraphQL. Подключаем babel в зависимости, и немного правим run dev скрипт для запуска nodaemon, чтобы он получал скомпилированные данные из ноды babel. Перезапускаем приложение, GUI GraphiQL теперь доступен на localhost:3000/graphql.
3. Самое время подключить Eslint и исправить ошибки в коде, которые он поможет нам найти, я использую air-bnb пресет для codestyle, ставим расширение и для реакта (пригодится уже во втором задании). Видим, что есть ошибка в корневом index.js, отсутствует зависимость body-parser, middleware для обработки POST-запросов, устанавливаем ее.
4. Проверяем запросы в GraphiQL согласно схеме. "query events" не возвращает значения, т.к. название переменной arguments в resolvers/query,js было изменено, исправляем это. Рисуем на листке бумаги схему БД, смотрим какие еще отношения нам могут понадобиться. Исправляем ошибку отсутствия return (в resolvers/index.js), добавляем отсутствующую ассоциацию User->Events, отсутствующий релейшен в models/scheme.js Room.hasMany(Event) (теперь мы можем запрашивать все события в определенной комнате). В graphQL файле, где описываются типы, добавляем в UserInput тип - необязательное поле avatarUrl (чтобы можно было создавать пользователя с изображениями и для Room - поле events: [Event], чтобы получать все события комнаты), добавляем в резолверы геттер для событий комнаты, чтобы это все заработало. В интерефейсе localhost:3000/graphiQL проверяем все мутации. Отсутствует резолвер для мутации addUserToEvent, напишем его. В резолвере changeEventRoom была допущенна ошибка, исправляем ее. Все мутации теперь работают.